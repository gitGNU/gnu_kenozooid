
# plot dive profiles
#

library(Hmisc)
library(grid)

annotate <- function(x, y, labels, cex=par('cex'), font=par('font')) {
    offset.x = strwidth('m') * 0.3 * cex
    offset.y = strheight('x') * 0.2 * cex
    labels.w = strwidth(labels, cex=cex, font=font) + 2 * offset.x
    labels.h = strheight(labels, cex=cex, font=font) + 2 * offset.y

    x = x + offset.x # add off parameter?
    y = y - offset.y - labels.h # add adj parameter?

    if (length(labels) > 1) {
        for (i in 2:length(labels)) {
            k = i - 1
            if (x[i] <= x[k] + labels.w[k] # sorted x -> this check is enough
                    && (y[k] + labels.h[k] <= y[i] && y[i] <= y[k]
                    || y[k] + labels.h[k] <= y[i] + labels.h[i] && y[i] + labels.h[i] <= y[k])) {
                x[i] = x[k] + offset.x
                y[i] = y[k] - labels.h[k] - offset.y
            }
        }
    }

    xs = x + labels.w
    ys = y + labels.h
    labels.x = x + offset.x
    labels.y = y + offset.y

    rect(x, y, xs, ys, col=rgb(1, 1, 1, 0.7), bg='white', border=NA)
    text(labels.x, labels.y, labels, adj=c(0, 0), cex=cex, font=font)
}

if (length(kz.args) != 3) {
    stop('Arguments required: output file, signature flag, output file format')
}

kz.args.fout = kz.args[1]
kz.args.sig = kz.args[2] == 'True'
kz.args.fmt = kz.args[3]

kz.args.width = 10
kz.args.height = 5

if (kz.args.fmt == 'pdf') {
    cairo_pdf(kz.args.fout, width=kz.args.width, height=kz.args.height, onefile=TRUE)
} else if (kz.args.fmt == 'png') {
    fimg = png
    kz.args.width = 900
    kz.args.height = 450
    png(kz.args.fout, width=kz.args.width, height=kz.args.height)
} else if (kz.args.fmt == 'svg') {
    svg(kz.args.fout, width=kz.args.width, height=kz.args.height)
}

if (is.null(kz.dives.ui$title))
    par(mar=c(5, 4, 1, 2) + 0.1)

for (i in 1:nrow(kz.dives)) {
    dive = kz.dives[i,]
    dive.title = if (is.null(kz.dives.ui$title)) NA else kz.dives.ui[i, 'title']
    dive.info = if (is.null(kz.dives.ui$info)) NA else kz.dives.ui[i, 'info']

    dp = kz.profiles[kz.profiles$dive == i, ]

    dive_time = dp$time / 60.0
    xlim = range(dive_time)
    ylim = rev(range(dp$depth))
    plot(NA, xlim=xlim, ylim=ylim,
        xlab='Time [min]', ylab='Depth [m]')

    # deco info
    if (any(!is.na(dp$deco_time))) {
        deco_depth = approxfun(dp$time, dp$deco_depth,
            method='constant', f=1)(dp$time)

        n = length(dp$time)
        dc = rep(rgb(0.90, 0.90, 1.0), n - 1)
        dc[which(dp$deco_alarm)] = rgb(1.0, 0.50, 0.50)
        rect(dive_time[1:n - 1], deco_depth[1:n - 1], dive_time[2:n], rep(0, n - 1),
            col=dc, border=dc)
    }

    # then the grid
    minor.tick(nx=5, ny=2)
    grid()

    # and finally plot the dive profile
    lines(dive_time, dp$depth, col='blue')

    # annotations
    labels = data.frame(depth=c(), time=c(), label=c(), pch=c())

    # setpoint change
    i_sp = which(!is.na(dp$setpoint))
    if (length(i_sp) > 0)
        labels = rbind(labels,
            data.frame(depth=dp$depth[i_sp],
                time=dive_time[i_sp],
                label=sprintf('SP %.2f', dp$setpoint[i_sp] / 100000.0),
                pch=c(25)
            )
        )

    # gas switch
    i_gas = which(!is.na(dp$gas_name))
    if (length(i_gas) > 0)
        labels = rbind(labels,
            data.frame(depth=dp$depth[i_gas],
                time=dive_time[i_gas],
                label=dp$gas_name[i_gas],
                pch=c(21)
            )
        )

    if (nrow(labels)) {
        labels = labels[order(labels$time), ]
        points(labels$time, labels$depth, pch=labels$pch, cex=0.5,
            col='blue', bg='white')
        annotate(labels$time, labels$depth, labels$label,
            font=2, cex=0.6)
    }

    if (!is.na(dive.title))
        title(sprintf('Dive %s', dive.title))

    if (!is.na(dive.info)) {
        info = textGrob(dive.info, gp=gpar(cex=0.7, font=2))
        pushViewport(viewport(0.9, 0.3,
            width=grobWidth(info) + unit(0.02, 'npc'),
            height=grobHeight(info) + unit(0.03, 'npc'),
            just=c('right', 'bottom')
        ))
        grid.rect(gp=gpar(alpha=0.8))
        grid.draw(info)
        popViewport()
    }

    if (kz.args.sig)
        grid.text(sprintf('generated by kenozooid ver. %s', kz.version),
            x=0.99, y=0.01, just=c('right', 'bottom'),
            gp=gpar(cex=0.6, fontface='italic'))
}

dev.off()

# vim: sw=4:et:ai
